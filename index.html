<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="Project website for WonderZoom">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="assets/fonts/open-sans.css">

    <title>WonderZoom</title>
    <link rel="icon" href="assets/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="assets/images/icons/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="assets/css/project.css">
    <link rel="stylesheet" href="assets/css/slick.css">
    <link rel="stylesheet" href="assets/css/slick-theme.css">

    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery-migrate.min.js"></script>
    <script src="assets/js/slick.min.js"></script>

</head>

<style>
    
    #canvas-container {
        background-color: rgb(178, 178, 178);
    }
    #canvas {
        display: block;
        top: 0;
        left: 0;
        width: 100%;
        height: auto;
    }
    .container{
        max-width: 1000px;
    }
    .arrow {
        border: solid black;
        border-width: 0 4px 4px 0;

        position: absolute;
        top: 50%;

        width: 20px;
        height: 20px;
        -webkit-transform: translate(0, -50%);
        -ms-transform: translate(0, -50%);
        transform: translate(0, -50%);
        cursor: pointer;
    }

    .right {
        transform: rotate(-45deg);
        -webkit-transform: rotate(-45deg);
        right: -25px;
    }

    .left {
        transform: rotate(135deg);
        -webkit-transform: rotate(135deg);
        left: -25px;
    }

    .nav-item img {
        max-width: 100%;
        /* Responsive media */
        height: auto;
        display: block;
    }

    .nav-item p {
        text-align: center;
        font-family: 'Open Sans', sans-serif;
        font-weight: 500;
        line-height: 1.5rem;
        font-size: 1.2rem;
        color: black;
    }

    .interactive-item {
        align-content: center;
    }

    .interactive-item video {
        max-width: 70%;
        max-height: 400px;
        justify-content: center;
        align-items: center;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }

    .interactive-item p {
        text-align: center;
        font-family: 'Open Sans', sans-serif;
        font-weight: 500;
        line-height: 1.5rem;
        font-size: 1.2rem;
        color: black;
    }

    .interactive-container {
        margin-bottom: 0rem;
        display: grid !important;
        grid-template-columns: 100%;
        grid-template-rows: 1fr;
        gap: 0% 1%;
        justify-content: center;
    }

    .generated-container {
      margin-bottom: 1rem;
      display: grid !important;
      grid-template-columns: 100%;
      grid-template-rows: 1fr;
      gap: 0% 1%;
      justify-content: center;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
  }

    .teaser-item {
        justify-content: center;
        align-items: center;
        display: flex;
    }

    .two-column-section {
      display: flex;
      width: 100%;
      border-left: 10px;
      border-right: 10px;
    }
    
    .two-column-section .column {
        padding: 0px;
        justify-content: center;
        align-items: center;
        text-align: center;
    }
    
    .two-column-section .first-column {
        width: 37%;
        padding-left: 2%;
    }
    
    .two-column-section .second-column {
        width: 63%;
        padding-right: 2%;
    }

    .slider-for-complete {
        display: flex !important;
        align-items: center;
        justify-content: center;
    }

    .slider-for-complete .slick-track {
        display: flex !important;
        align-items: center;
    }

    .slider-for-complete .slick-slide {
        display: flex !important;
        justify-content: center;
        align-items: center;
    }

</style>

<body>
    <section>
        <div class="container">
            <div class="container">
                <div class="row justify-content-center">
                    <div class="col-md-7 col-sm-12 mt-4">
                        <img src="assets/images/icons/logo.png" alt="WonderZoom:" class="img-fluid">
                    </div>
                </div>
            </div>
            <div class="row" id="title">
                <p class="col text-center text-title">
                    Multi-Scale 3D World Generation
                </p>
            </div>
        </div>

        <div class="row" id="authors">
          <div class="col-md-12 text-center mt-2 text-author">
              <ul class="list-inline">

                  <li class="list-inline-item mx-2">
                          <p><b>Anonymous Authors<b></p>
                  </li>
              </ul>

          </div>
      </div>


    </section>


 

    <section>
        <div class="container">
            <div class="row">
                <div class="col my-3">
                  
                  <div class="row">
                    <div class="col text-center my-4">
                        <img src="./assets/images/approach/teaser_img.png" class="img-fluid" alt="Teaser Image" style="max-width: 100%; height: auto;">
                    </div>
                  </div>

                    <div class="teaser-item">
                      <p class="body-text">
                        <b>WonderZoom</b> enables interactive exploration across spatial scales. Users can zoom into any region and specify prompts to generate new fine-scale content while maintaining cross-scale consistency. Here we show three zoom-in sequences
                      </p>
                  </div>
                </div>
            </div>

            </div>
        </div>


    </section>


    <section>
        <div class="container">
            <div class="row">
                <div class="col my-3">
                    <p class="text-header">
                        Generated Multi-Scale Worlds<br>
                    </p>
                </div>
            </div>
        </div>

        <div class="container slider-for-complete">

            <div class="container generated-container">
                <div class="interactive-item">
                    <video muted controls loop playsinline webkit-playsinline>
                        <source data-lazy="assets/videos/overall.mp4"
                            type="video/mp4">
                    </video>
                </div>
            </div>

            <div class="container generated-container">
                <div class="interactive-item">
                    <video muted controls loop playsinline webkit-playsinline>
                        <source src="assets/videos/demo_ladybug_1080.mp4"
                            type="video/mp4">
                    </video>
                </div>
            </div>

            <div class="container generated-container">
                <div class="interactive-item">
                    <video muted controls loop playsinline webkit-playsinline>
                        <source src="assets/videos/demo_conch1080.mp4" type="video/mp4">
                    </video>
                </div>
            </div>

            <div class="container generated-container">
              <div class="interactive-item">
                  <video muted controls loop playsinline webkit-playsinline>
                      <source src="assets/videos/beach2.mp4" type="video/mp4">
                  </video>
              </div>
          </div>

            <div class="container generated-container">
                <div class="interactive-item">
                    <video muted controls loop playsinline webkit-playsinline>
                        <source src="assets/videos/demo_fish_1080.mp4" type="video/mp4">
                    </video>
                </div>
            </div>

            <div class="container generated-container">
                <div class="interactive-item">
                    <video muted controls loop playsinline webkit-playsinline>
                        <source src="assets/videos/demo_lego.mp4" type="video/mp4">
                    </video>
                </div>
            </div>

            <div class="container generated-container">
                <div class="interactive-item">
                    <video muted controls loop playsinline webkit-playsinline>
                        <source src="assets/videos/demo_butterfly1080.mp4" type="video/mp4">
                    </video>
                </div>
            </div>

            <div class="container generated-container">
              <div class="interactive-item">
                  <video muted controls loop playsinline webkit-playsinline>
                      <source src="assets/videos/butterfly2.mp4" type="video/mp4">
                  </video>
              </div>
          </div>

            <div class="container generated-container">
                <div class="interactive-item">
                    <video muted controls loop playsinline webkit-playsinline>
                        <source src="assets/videos/demo_beetle1080.mp4" type="video/mp4">
                    </video>
                </div>
            </div>

            <div class="container generated-container">
                <div class="interactive-item">
                    <video muted controls loop playsinline webkit-playsinline>
                        <source src="assets/videos/demo_lizard.mp4" type="video/mp4">
                    </video>
                </div>
            </div>



        </div>

        <div class="container slider-nav-complete">

            <div class="container nav-item">
              <img data-lazy="assets/images/complete/street.png">
              <p>Street</p>
            </div>

            <div class="container nav-item">
              <img data-lazy="assets/images/complete/sunf.png">
              <p>Sunflower</p>
            </div>

            <div class="container nav-item">
                <img data-lazy="assets/images/complete/beach.jpg">
                <p>Beach1</p>
            </div>

            <div class="container nav-item">
              <img data-lazy="assets/images/complete/beach2.png">
              <p>Beach2</p>
          </div>

            <div class="container nav-item">
                <img data-lazy="assets/images/complete/coral.png">
                <p>Coral</p>
            </div>

            <div class="container nav-item">
                <img data-lazy="assets/images/complete/deng.png">
                <p>House</p>
            </div>

            <div class="container nav-item">
                <img data-lazy="assets/images/complete/tea_garden.jpg">
                <p>Tea Garden1</p>
            </div>

            <div class="container nav-item">
              <img data-lazy="assets/images/complete/tea_garden2.png">
              <p>Tea Garden2</p>
          </div>

            <div class="container nav-item">
                <img data-lazy="assets/images/complete/Tree.png">
                <p>Tree</p>
            </div>

            <div class="container nav-item">
                <img data-lazy="assets/images/complete/wooden.jpg">
                <p>Wooden</p>
            </div>



        </div>

    </section>

    <section>
      <div class="container">
          <div class="row">
              <div class="col my-3">
                  <p class="text-header">
                      Interactive Viewing
                  </p>
                  <div class="teaser-item">
                      <p class="body-text">
                          <b>Keyboard:</b> Move by "W/A/S/D", look around by "I/J/K/L". Rotate around the center point by "F". Click the button "Scale 0/1/2" to zoom-in/out.<br>
                          <b>Note: </b> Clicking an image will automatically download a generated world example from an <b>anonymous source</b>. After loading, please click on the canvas to activate control. The rendering here is done on your device in real-time. <b>Downloading an example (~100MB) may take a while.</b> Since the web renderer does not support our proposed multi-scale representation rendering and it applies depth quantization, <b>the rendering quality is degraded compared to the videos above.</b>
                      </p>
                  </div>
                  <div class="teaser-item my-2" id="buttonContainer">
                      <button class="button active">Clear</button>
                       <button class="button-img" data-url="https://huggingface.co/datasets/anonymous1273891/wonderzoom1/resolve/main/ladybug_shift_spark.splat?download=true">
                           <img src="assets/images/complete/sunf.png" alt="Beach" style="width: 100%; height: auto;">
                       </button>
                       <button class="button-img" data-url="https://huggingface.co/datasets/anonymous1273891/wonderzoom1/resolve/main/bird_shift_spark.splat?download=true">
                           <img src="assets/images/complete/street1.png" alt="Coral" style="width: 100%; height: auto;">
                       </button>
                       <button class="button-img" data-url="https://huggingface.co/datasets/anonymous1273891/wonderzoom1/resolve/main/conch_shift_spark.splat?download=true">
                           <img src="assets/images/complete/beach2.png" alt="Sunflower" style="width: 100%; height: auto;">
                       </button>
                    <button class="button-img" data-url="https://huggingface.co/datasets/anonymous1273891/wonderzoom1/resolve/main/butterfly_shift_spark.splat?download=true">
                        <img src="assets/images/complete/tea_garden2.png" alt="Tree" style="width: 100%; height: auto;">
                    </button>
                  <button class="button-img" data-url="https://huggingface.co/datasets/anonymous1273891/wonderzoom1/resolve/main/fish_shift_spark.splat?download=true">
                      <img src="assets/images/complete/coral.png" alt="Tree" style="width: 100%; height: auto;">
                  </button>

                  <button class="button-img" data-url="https://huggingface.co/datasets/anonymous1273891/wonderzoom1/resolve/main/lizard_shift_spark.splat?download=true">
                    <img src="assets/images/complete/wooden.jpg" alt="Tree" style="width: 100%; height: auto;">
                </button>

                <button class="button-img" data-url="https://huggingface.co/datasets/anonymous1273891/wonderzoom1/resolve/main/lego_shift_spark.splat?download=true">
                  <img src="assets/images/complete/deng.png" alt="Tree" style="width: 100%; height: auto;">
              </button>


                  </div>
                  <div id="message"></div>
                  
                  <!-- Scale Controls -->
                  <div class="teaser-item my-2" id="scaleContainer">
                      <button class="button scale-button active" data-scale="0">Scale 0</button>
                      <button class="button scale-button" data-scale="1">Scale 1</button>
                      <button class="button scale-button" data-scale="2">Scale 2</button>
                  </div>
                  
                  <!-- ğŸ¯ Download Progress Bar -->
                  <div id="download-progress-container" style="display: none; width: 60%; margin: 10px auto; font-family: monospace;">
                    <div style="color: #333; font-size: 12px; margin-bottom: 5px; text-align: center;">
                      <span id="download-status">Downloading...</span>
                      <span id="download-percentage">0%</span>
                    </div>
                    <div style="background: #e0e0e0; border-radius: 10px; overflow: hidden; height: 8px;">
                      <div id="download-progress-bar" style="background: linear-gradient(90deg, #4CAF50, #2196F3); height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 10px;"></div>
                    </div>
                    <div style="color: #666; font-size: 10px; margin-top: 3px; text-align: center;">
                      <span id="download-size">0 MB / 0 MB</span>
                      <span style="margin-left: 15px;">Speed: <span id="download-speed">0 KB/s</span></span>
                      <span style="margin-left: 15px;">ETA: <span id="download-eta">--:--</span></span>
                    </div>
                  </div>
                  
                  <!-- ğŸ¯ Spark -->
                  <div class="teaser-item" id="spark-renderer-container" style="position: relative; width: 60%; height: 350px; background: #202840; border-radius: 8px; overflow: hidden; margin: 0 auto;">
                    <div id="spark-ui" style="position: absolute; top: 10px; left: 10px; z-index: 10; font-family: sans-serif; font-size: 11px; line-height: 1.3; color: #fff; background: rgba(0,0,0,.4); padding: 5px 8px; border-radius: 4px; user-select: none; pointer-events: none;">
                      Drag & drop <b>.splat/.spz/.ply</b> files<br>or <b>double-click</b> to open
                    </div>
                    <div id="spark-info" style="position: absolute; top: 10px; right: 10px; z-index: 10; font-family: monospace; font-size: 10px; line-height: 1.2; color: #fff; background: rgba(0,0,0,.6); padding: 6px 8px; border-radius: 4px; user-select: none; pointer-events: none; min-width: 140px;">
                      <div>FOV: <span id="spark-fov">18.9Â°</span></div>
                      <div>Focal: <span id="spark-focal">1441px</span></div>
                      <div>FPS: <span id="spark-fps">0</span></div>
                      <div>Position:</div>
                      <div>&nbsp;&nbsp;X: <span id="spark-posX">0.00</span></div>
                      <div>&nbsp;&nbsp;Y: <span id="spark-posY">0.00</span></div>
                      <div>&nbsp;&nbsp;Z: <span id="spark-posZ">0.10</span></div>
                      <div>Rotation:</div>
                      <div>&nbsp;&nbsp;X: <span id="spark-rotX">0.00Â°</span></div>
                      <div>&nbsp;&nbsp;Y: <span id="spark-rotY">0.00Â°</span></div>
                      <div>&nbsp;&nbsp;Z: <span id="spark-rotZ">0.00Â°</span></div>
                      <div>Splats: <span id="spark-splatCount">0</span></div>
                      <div>Rendered: <span id="spark-renderedCount">?</span></div>
                      <div>Speed Factor: <span id="spark-speedFactor">1.00</span></div>
                      <div>Orbit: <span id="spark-orbitStatus">OFF</span></div>
                      <div>Split: <span id="spark-splitStatus">OFF</span></div>
                    </div>
                    
                    <!-- ğŸ¯ é”®ç›˜æŒ‰é”®æ˜¾ç¤º -->
                    <!-- å·¦ä¸‹è§’ï¼šç§»åŠ¨æ§åˆ¶ WASD + F -->
                    <div id="keyboard-move" style="position: absolute; bottom: 20px; left: 20px; z-index: 10; font-family: monospace; font-size: 14px; user-select: none; pointer-events: none;">
                      <div style="text-align: center;">
                        <div style="color: #fff; font-size: 10px; margin-bottom: 5px;">Move</div>
                        <div style="display: flex; justify-content: center; align-items: flex-end; gap: 2px;">
                          <div></div>
                          <div class="key-btn" data-key="KeyW" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 8px; border-radius: 4px;margin-left: 20px; color: #fff; transition: all 0.1s;">W</div>
                          <div></div>
                          <div></div>
                          <div style="display: flex; flex-direction: column; align-items: center;">
                             <div style="color: #aaa; font-size: 8px; margin-bottom: 2px; margin-left: 25px; white-space: nowrap;">Orbit</div>
                            <div></div>
                          </div>
                        </div>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 2px; margin-top: 2px;">
                          <div class="key-btn" data-key="KeyA" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 8px; border-radius: 4px; color: #fff; transition: all 0.1s;">A</div>
                          <div class="key-btn" data-key="KeyS" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 8px; border-radius: 4px; color: #fff; transition: all 0.1s;">S</div>
                          <div class="key-btn" data-key="KeyD" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 8px; border-radius: 4px; color: #fff; transition: all 0.1s;">D</div>
                          <div class="key-btn" data-key="KeyF" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 8px; border-radius: 4px; color: #fff; transition: all 0.1s;">F</div>
                        </div>
                      </div>
                    </div>
                    
                    <!-- å³ä¸‹è§’ï¼šè§†è§’æ§åˆ¶ IJKL -->
                    <div id="keyboard-look" style="position: absolute; bottom: 20px; right: 20px; z-index: 10; font-family: monospace; font-size: 14px; user-select: none; pointer-events: none;">
                      <div style="text-align: center;">
                        <div style="color: #fff; font-size: 10px; margin-bottom: 5px;">Look</div>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 2px;">
                          <div></div>
                          <div class="key-btn" data-key="KeyI" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 8px; border-radius: 4px; color: #fff; transition: all 0.1s;">I</div>
                          <div></div>
                        </div>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 2px; margin-top: 2px;">
                          <div class="key-btn" data-key="KeyJ" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 8px; border-radius: 4px; color: #fff; transition: all 0.1s;">J</div>
                          <div class="key-btn" data-key="KeyK" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 8px; border-radius: 4px; color: #fff; transition: all 0.1s;">K</div>
                          <div class="key-btn" data-key="KeyL" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 8px; border-radius: 4px; color: #fff; transition: all 0.1s;">L</div>
                        </div>
                      </div>
                    </div>
                  </div>
              </div>
          </div>
      </div>

  </section>

    <section>
        <div class="container">
            <div class="row" id="approach">
                <div class="col my-3">
                    <p class="text-header">
                        Approach
                    </p>
                    <div class="container">
                        <img src="assets/images/approach/approach.jpg" class="approach-figure">
                    </div>
                    <p class="body-text" style="margin-top: 1rem;">
                      From an input image, we first reconstruct an initial 3D scene. Users specify prompts and camera viewpoints to generate finer-scale content. Our progressive detail synthesizer creates new-scale images, registers depth to maintain geometric consistency, and synthesizes auxiliary views for complete 3D scene creation. Our scale-adaptive Gaussian surfels enable dynamic updates without re-optimization, seamlessly integrating new content while preserving real-time rendering.
                  </p>
                </div>
            </div>
        </div>
    </section>



    <script type="text/javascript">
        $(document).ready(function () {
            // Interactive slider initialization (keep this as it was)
            $('.slider-for-interactive').on('beforeChange', function (event, slick, currentSlide, nextSlide) {
                var video = $(slick.$slides[nextSlide]).find('video');
                var videoSource = video.find('source[data-lazy]');
                if (videoSource.length) {
                    videoSource.attr('src', videoSource.data('lazy'));
                    videoSource.removeAttr('data-lazy');
                    video.get(0).load();
                }
            });
            $('.slider-nav-interactive').slick({
                slidesToShow: 3,
                slidesToScroll: 1,
                asNavFor: '.slider-for-interactive',
                dots: true,
                centerMode: true,
                centerPadding: '10%',
                focusOnSelect: true,
                nextArrow: '<div class="arrow right"></div>',
                prevArrow: '<div class="arrow left"></div>',
            });
            $('.slider-for-interactive').slick({
                slidesToShow: 1,
                slidesToScroll: 1,
                arrows: false,
                asNavFor: '.slider-nav-interactive',
                autoplay: true,
                speed: 300,
                autoplaySpeed: 100000,
            });
    
            // Complete slider initialization (modified)
            $('.slider-for-complete').on('init', function(event, slick){
                var firstVideo = $(slick.$slides[0]).find('video');
                var firstVideoSource = firstVideo.find('source');
                if (firstVideoSource.attr('data-lazy')) {
                    firstVideoSource.attr('src', firstVideoSource.attr('data-lazy'));
                    firstVideoSource.removeAttr('data-lazy');
                    firstVideo[0].load();
                    firstVideo[0].play();
                }
            });
    
            $('.slider-for-complete').on('beforeChange', function (event, slick, currentSlide, nextSlide) {
                var nextSlideElem = $(slick.$slides[nextSlide]);
                var video = nextSlideElem.find('video');
                var source = video.find('source');
                
                if (source.attr('data-lazy')) {
                    source.attr('src', source.attr('data-lazy'));
                    source.removeAttr('data-lazy');
                    video[0].load();
                }
            });
    
            $('.slider-for-complete').on('afterChange', function(event, slick, currentSlide) {
                var currentSlideElem = $(slick.$slides[currentSlide]);
                var video = currentSlideElem.find('video');
                if (video.length) {
                    video[0].play();
                }
            });
    
            $('.slider-nav-complete').slick({
                slidesToShow: 3,
                slidesToScroll: 1,
                asNavFor: '.slider-for-complete',
                dots: true,
                centerMode: true,
                centerPadding: '10%',
                focusOnSelect: true,
                nextArrow: '<div class="arrow right"></div>',
                prevArrow: '<div class="arrow left"></div>',
            });
    
            $('.slider-for-complete').slick({
                slidesToShow: 1,
                slidesToScroll: 1,
                arrows: false,
                asNavFor: '.slider-nav-complete',
                autoplay: true,
                speed: 300,
                autoplaySpeed: 100000,
                lazyLoad: 'ondemand',
                centerMode: true,
                centerPadding: '0px'
            });
        });
    </script>
    <script src="assets/js/canvas.js"></script>
    
    <!-- ğŸ¯ Spark -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.174/build/three.module.js",
          "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.8/spark.module.js"
        }
      }
    </script>
    <script type="module">
      // ğŸ¯ WebGL
      window.addEventListener('error', function(e) {
       // if (e.message && e.message.includes('getContext')) {
      //    e.preventDefault();
         // return false;
        //}
      });
      
      import * as THREE from "three";
      import { SplatMesh, SplatFileType, SparkControls, SparkRenderer } from "@sparkjsdev/spark";

      // ğŸ¯ 
      let splatFirst = null;  // 50%splat
      let splatSecond = null; // 50%splat
      let currentFileType = null; // 
      let sparkWorldOffset = [0, 0, 0];
      let sparkRadiusCenter = [0, 0, 0];

      const ZERO_VECTOR = [0, 0, 0];

      function subtractVectors(a = ZERO_VECTOR, b = ZERO_VECTOR) {
        return [
          (a[0] ?? 0) - (b[0] ?? 0),
          (a[1] ?? 0) - (b[1] ?? 0),
          (a[2] ?? 0) - (b[2] ?? 0)
        ];
      }

      function translateBbox(bbox = [], offset = ZERO_VECTOR) {
        if (!Array.isArray(bbox) || bbox.length < 4) return bbox;
        const translated = [...bbox];
        translated[0] = (bbox[0] ?? 0) - (offset[0] ?? 0); // minX
        translated[1] = (bbox[1] ?? 0) - (offset[0] ?? 0); // maxX
        translated[2] = (bbox[2] ?? 0) - (offset[2] ?? 0); // minZ
        translated[3] = (bbox[3] ?? 0) - (offset[2] ?? 0); // maxZ
        // æ³¨æ„ï¼špitchå’Œyawé™åˆ¶ä¸éœ€è¦å¹³ç§»ï¼Œå› ä¸ºå®ƒä»¬ä¸æ˜¯ç©ºé—´åæ ‡
        return translated;
      }

      // ğŸ¯ Spark
      function initSparkRenderer() {
        const container = document.getElementById('spark-renderer-container');
        if (!container) return;

         const canvas = document.createElement('canvas');
         canvas.style.width = '100%';
         canvas.style.height = '100%';
         canvas.style.display = 'block';
         container.appendChild(canvas);

          // 
          const rect = container.getBoundingClientRect();
          const width = rect.width || 600;  // 
          const height = rect.height || 350; // 
         
         // canvas
         canvas.width = width;
         canvas.height = height;

                 // 
         const scene = new THREE.Scene();
         scene.background = new THREE.Color(0x202840);
         
         // 
         window.sparkScene = scene;
         window.sparkTargetPosition = [...ZERO_VECTOR];
         window.sparkWorldOffset = [...ZERO_VECTOR];
         sparkRadiusCenter = [...ZERO_VECTOR];
         window.sparkRadiusCenter = [...sparkRadiusCenter];

                 // 
         const camera = new THREE.PerspectiveCamera(2 * Math.atan((480/2) / 1441) * 180 / Math.PI, width/height, 0.1, 10000);
         camera.position.set(0,0,6.88);
         
         // 
         window.sparkCamera = camera;
         window.sparkCameraTransitioning = false;

                 // 
         const renderer = new THREE.WebGLRenderer({
           antialias: false, 
           logarithmicDepthBuffer: false, 
           canvas: canvas,
           alpha: true,
           preserveDrawingBuffer: false
         });
         renderer.setPixelRatio(devicePixelRatio);
         renderer.setSize(width, height);
         renderer.setClearColor(0x202840, 1);

        // 
        const controls = new SparkControls({ canvas: renderer.domElement });
        controls.pointerControls.enable = false;
        
        // ğŸ¯ Sparkæ¸²æŸ“å™¨é…ç½®ï¼šå¯ç”¨32ä½ç²¾åº¦æ’åºï¼Œä¿æŒå¾„å‘è·ç¦»æ’åº
        const sparkRenderer = new SparkRenderer({
          renderer,
          view: {
            sort32: true,
            sortRadial: true
          }
        });
        scene.add(sparkRenderer);
        
        // controls
        window.sparkControls = controls;
        
        // 
        renderer.domElement.addEventListener('mousedown', (e) => e.preventDefault(), { passive: false });
        renderer.domElement.addEventListener('mousemove', (e) => e.preventDefault(), { passive: false });
        renderer.domElement.addEventListener('mouseup', (e) => e.preventDefault(), { passive: false });
        renderer.domElement.addEventListener('wheel', (e) => e.preventDefault(), { passive: false });
        
        // 
        let baseMoveSpeed = 1.0;
        let baseRotateSpeed = 2e-3;
        
        function getSpeedFactor() {
          const currentFocal = fovToFx(camera.fov);
          return Math.pow(1441 / currentFocal, 1)*0.4;
        }
        
                 // 
         let activeKeys = [];
         let yaw = 0;
         let pitch = 0;
         
         // yawpitch
         window.sparkLocalYaw = yaw;
         window.sparkLocalPitch = pitch;
         
         // yawpitch
         window.resetLocalRotation = function() {
           yaw = 0;
           pitch = 0;
           window.sparkLocalYaw = yaw;
           window.sparkLocalPitch = pitch;
           console.log('ğŸ¯ rotation: yaw=0, pitch=0');
         };
         
         // yawpitch
         window.updateLocalRotation = function(newYaw, newPitch) {
           yaw = newYaw;
           pitch = newPitch;
           window.sparkLocalYaw = yaw;
           window.sparkLocalPitch = pitch;
         };
         
         // 
         let orbitMode = false;
         
        // 
        window.sparkYaw = yaw;
        window.sparkPitch = pitch;
        window.sparkOrbitMode = orbitMode;
       let orbitStartTime = 0;
       let orbitDuration = 1600;
       let orbitRadius = 0.1;
       // 
       window.sparkOrbitRadius = orbitRadius;
        let orbitCenter = new THREE.Vector3();
        let originalCameraPosition = new THREE.Vector3();
        let originalCameraRotation = new THREE.Euler();
        
                 //  
         document.addEventListener("sparkKeyDown", (e) => {
           const keyCode = e.detail.code;
           
           // 
           if (keyCode === "KeyF") {
             if (!orbitMode) {
               startOrbitCamera();
             }
             // ï¼Œ
             return;
           }
           
           // 
           if (!activeKeys.includes(keyCode)) {
             activeKeys.push(keyCode);
            /// console.log('ğŸ® :', keyCode, ':', activeKeys);
           }
         });
        
                 // keyup 
         document.addEventListener('keyup', (e) => {
           const controlKeys = ['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyF', 'KeyV', 'KeyB', 
                               'KeyI', 'KeyJ', 'KeyK', 'KeyL'];
           
           if (controlKeys.includes(e.code)) {
             if (!document.activeElement || 
                 (document.activeElement.tagName !== 'INPUT' && 
                  document.activeElement.tagName !== 'TEXTAREA' && 
                  document.activeElement.contentEditable !== 'true')) {
               
               activeKeys = activeKeys.filter((k) => k !== e.code);
               console.log('ğŸ® :', e.code, ':', activeKeys,"pitch:", pitch, "yaw:", yaw);
             }
           }
         });
        
        window.addEventListener("blur", () => {
          activeKeys = [];
        });
        
        // 
        function startOrbitCamera() {
          if (orbitMode) return;
          
          orbitMode = true;
          orbitStartTime = performance.now();
          
          originalCameraPosition.copy(camera.position);
          originalCameraRotation.copy(camera.rotation);
          
          const forward = new THREE.Vector3(0, 0, -1);
          forward.applyQuaternion(camera.quaternion);
          // 
          orbitCenter.copy(camera.position);
          
          console.log("ğŸ¬ ");
        }
        
        function updateOrbitCamera() {
          if (!orbitMode) return;
          
          const currentTime = performance.now();
          const elapsed = currentTime - orbitStartTime;
          const progress = (elapsed % orbitDuration) / orbitDuration;
          
          const angle = progress * Math.PI * 2;
          
          const currentOrbitRadius = window.sparkOrbitRadius || orbitRadius;
          const orbitX = orbitCenter.x + currentOrbitRadius * Math.cos(angle);
          const orbitZ = orbitCenter.z;
          const orbitY = orbitCenter.y + currentOrbitRadius * Math.sin(angle);
          
          camera.position.set(orbitX, orbitY, orbitZ);
          
          let orbitCenter_target = new THREE.Vector3();
          orbitCenter_target.copy(orbitCenter);
          // lookAt - ä½¿ç”¨sparkTargetPositionï¼Œå› ä¸ºç›®æ ‡åœ°åŒºå·²ç»ç§»åˆ°[0,0,0]
          if (window.sparkTargetPosition) {
            orbitCenter_target.set(window.sparkTargetPosition[0], window.sparkTargetPosition[1], window.sparkTargetPosition[2]);
          }
          else{
            orbitCenter_target.set(0,0,0);
          }
          camera.lookAt(orbitCenter_target);
          
          if (elapsed >= orbitDuration) {
            // ğŸ¯ è½¨é“ç»“æŸåï¼Œå›åˆ°å½“å‰scaleçš„åˆå§‹çŠ¶æ€
            returnToCurrentScaleState();
            stopOrbitCamera();
          }
        }
        
        // ğŸ¯ è½¨é“ç»“æŸåå›åˆ°å½“å‰scaleçš„åˆå§‹çŠ¶æ€
        function returnToCurrentScaleState() {
          // è·å–å½“å‰æ¿€æ´»çš„scale
          const activeScaleButton = document.querySelector('.scale-button.active');
          if (!activeScaleButton) {
            console.log('ğŸ¯ æœªæ‰¾åˆ°æ¿€æ´»çš„scaleæŒ‰é’®ï¼Œå›åˆ°åŸå§‹ä½ç½®');
            return;
          }
          
          const currentScale = activeScaleButton.dataset.scale;
          const currentScaleSettings = getScaleSettings(currentScale);
          
          if (currentScaleSettings) {
            // è®¾ç½®ç›¸æœºä½ç½®
            camera.position.set(
              currentScaleSettings.position[0],
              currentScaleSettings.position[1], 
              currentScaleSettings.position[2]
            );

            const newRadiusCenter = currentScaleSettings.radiusCenter || currentScaleSettings.position || ZERO_VECTOR;
            sparkRadiusCenter = [...newRadiusCenter];
            window.sparkRadiusCenter = [...sparkRadiusCenter];

            if (currentScaleSettings.radius !== undefined) {
              window.sparkRadius = currentScaleSettings.radius;
            }
            
            // è®¾ç½®focal length
            function fovToFx(fov, h = 480) { 
              return (h/2)/Math.tan(THREE.MathUtils.degToRad(fov)/2); 
            }
            const newFov = 2 * Math.atan((480/2) / currentScaleSettings.focal) * 180 / Math.PI;
            camera.fov = newFov;
            camera.updateProjectionMatrix();
            
            // æ›´æ–°å…¨å±€yawå’Œpitch
            yaw = currentScaleSettings.yaw;
            pitch = currentScaleSettings.pitch;
            window.sparkLocalYaw = currentScaleSettings.yaw;
            window.sparkLocalPitch = currentScaleSettings.pitch;
            
            console.log(`ğŸ¯ è½¨é“ç»“æŸï¼Œå›åˆ°Scale ${currentScale}çš„åˆå§‹çŠ¶æ€: position[${currentScaleSettings.position}], focal:${currentScaleSettings.focal}, yaw:${currentScaleSettings.yaw.toFixed(4)}, pitch:${currentScaleSettings.pitch.toFixed(4)}`);
          }
        }

        // ğŸ¯ ä»ç›¸æœºçš„rotationæ›´æ–°å…¨å±€yawå’Œpitchå˜é‡
        function updateGlobalRotationFromCamera() {
          // ä»ç›¸æœºçš„rotationæå–yawå’Œpitch
          const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
          const newPitch = euler.x;
          const newYaw = euler.y;
          
          // æ›´æ–°å…¨å±€å˜é‡
          yaw = newYaw;
          pitch = newPitch;
          window.sparkLocalYaw = newYaw;
          window.sparkLocalPitch = newPitch;
          
          console.log(`ğŸ¯ è½¨é“ç»“æŸï¼Œæ›´æ–°å…¨å±€rotation: yaw=${newYaw.toFixed(4)}, pitch=${newPitch.toFixed(4)}`);
        }

        function stopOrbitCamera() {
          if (!orbitMode) return;
          
          orbitMode = false;
          console.log("ğŸ¬ ");
        }
        
                 // controlsupdate
         controls.update = function(control) {
           const speedFactor = getSpeedFactor();
           
           updateOrbitCamera();
           
           if (!orbitMode) {
             // 
             if (!window.sparkCameraTransitioning) {
               // IJKL
               if (activeKeys.includes("KeyJ")) {
                 yaw += 0.005 * speedFactor;
                 window.sparkLocalYaw = yaw;
               }
               if (activeKeys.includes("KeyL")) {
                 yaw -= 0.005 * speedFactor;
                 window.sparkLocalYaw = yaw;
               }
               if (activeKeys.includes("KeyI")) {
                 pitch += 0.005 * speedFactor;
                 window.sparkLocalPitch = pitch;
               }
               if (activeKeys.includes("KeyK")) {
                 pitch -= 0.005 * speedFactor;
                 window.sparkLocalPitch = pitch;
               }
               
               pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
               window.sparkLocalPitch = pitch;
               
               // ğŸ¯  - pitchyaw
               if (window.sparkBbox) {
                 pitch = Math.max(window.sparkBbox[4], Math.min(window.sparkBbox[5], pitch));
                 yaw = Math.max(window.sparkBbox[6], Math.min(window.sparkBbox[7], yaw));
                 window.sparkLocalPitch = pitch;
                 window.sparkLocalYaw = yaw;
               }
             }
             
             control.rotation.set(pitch, yaw, 0, 'YXZ');
           }
          
                     if (controls.fpsMovement && !orbitMode) {
             const time = performance.now();
             const deltaTime = (time - (controls.lastTime || time)) / 1e3;
             controls.lastTime = time;
             
             const originalMoveSpeed = controls.fpsMovement.moveSpeed;
             controls.fpsMovement.moveSpeed = baseMoveSpeed * speedFactor;
             
             const originalKeycodeMoveMapping = controls.fpsMovement.keycodeMoveMapping;
             controls.fpsMovement.keycodeMoveMapping = {
               KeyW: new THREE.Vector3(0, 0, -1),  // 
               KeyS: new THREE.Vector3(0, 0, 1),   // 
               KeyA: new THREE.Vector3(-1, 0, 0),  // 
               KeyD: new THREE.Vector3(1, 0, 0)    // 
             };
             
             controls.fpsMovement.update(deltaTime, control);
             
             // ğŸ¯  - 
             if (window.sparkBbox) {
               control.position.x = Math.max(window.sparkBbox[0], Math.min(window.sparkBbox[1], control.position.x));
               control.position.z = Math.max(window.sparkBbox[2], Math.min(window.sparkBbox[3], control.position.z));
             }
             
             // ğŸ¯  - canvas.js
            if (window.sparkRadius && window.sparkRadius < 9999 && !window.sparkCameraTransitioning) {
              const radiusCenter = window.sparkRadiusCenter || ZERO_VECTOR;
              const centerX = radiusCenter[0] ?? 0;
              const centerY = radiusCenter[1] ?? 0;
              const centerZ = radiusCenter[2] ?? 0;
              const dx = control.position.x - centerX;
              const dy = control.position.y - centerY;
              const dz = control.position.z - centerZ;
              const distance = Math.hypot(dx, dy, dz);
              if (distance > window.sparkRadius) {
                const factor = window.sparkRadius / distance;
                control.position.x = centerX + dx * factor;
                control.position.y = centerY + dy * factor;
                control.position.z = centerZ + dz * factor;
                console.log(`ğŸ¯ : ${distance.toFixed(3)} > ${window.sparkRadius}, `);
              }
            }
             
             controls.fpsMovement.moveSpeed = originalMoveSpeed;
             controls.fpsMovement.keycodeMoveMapping = originalKeycodeMoveMapping;
           }
        };
        
                 let splat = null;

         // 
         async function loadFile(file) {
           if (!file) return;
           const ext = file.name.split(".").pop().toLowerCase();

           if (splat) { scene.remove(splat); splat.dispose?.(); }
           
           // 
           if (window.sparkSplat) { 
             window.sparkScene.remove(window.sparkSplat); 
             window.sparkSplat.dispose?.(); 
             window.sparkSplat = null;
           }

          if (ext === "splat") {
            console.log("Loading .splat with fileBytes + enum...");
            try {
              const buffer = await file.arrayBuffer();
              splat = new SplatMesh({
                fileBytes: new Uint8Array(buffer),
                fileType: SplatFileType.SPLAT
              });
              splat.quaternion.set(1, 0, 0, 0);
              splat.rotateZ(Math.PI);
              scene.add(splat);
                           await splat.initialized;
             window.splat = splat;
             window.sparkSplat = splat; // Spark

             console.log('SplatMesh keys:', Object.keys(splat));
              if (splat.material) {
                console.log('material type:', splat.material.type);
                console.log('material keys:', Object.keys(splat.material));
              } else {
                console.log('âš ï¸ splat.material is undefined');
              }

              if (splat.material && splat.material.uniforms) {
                const u = splat.material.uniforms;
                for (const k in u){
                  console.log(k, 'â†’', u[k].value);
                }
              } else {
                console.log('âš ï¸ splat.material.uniforms is undefined');
              }
              if (splat.packedSplats) {
                const p = splat.packedSplats;
                console.log("packedSplats keys â†’", Object.keys(p));
                
                const scaleKey = Object.keys(p).find(k => /scale/i.test(k));
                const rotKey = Object.keys(p).find(k => /rot/i.test(k));
                
                if (scaleKey && rotKey && p[scaleKey] && p[rotKey]) {
                  console.log("scaleX (5):", Array.from(p[scaleKey].slice(0,5)));
                  console.log("rotX   (5):", Array.from(p[rotKey].slice(0,5)));
                } else {
                  console.log("âš ï¸  scale/rot ï¼Œ");
                }
              } else {
                console.log("âš ï¸ splat.packedSplats ");
              }

            } catch (err) {
              console.error("âŒ Failed to load .splat:", err);
            }
            
            // ğŸ¯ .splat
            if (!window.sparkBbox || window.sparkBbox[0] === -9999) {
              window.sparkBbox = [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05];
              console.log('ğŸ¯ .splatbbox:', window.sparkBbox);
            }
            if (!window.sparkFocalBounds) {
              window.sparkFocalBounds = [1441, 999999999999999000];
              console.log('ğŸ¯ .splatfocal:', window.sparkFocalBounds);
            }
            if (!window.sparkRadius) {
              window.sparkRadius = 99999;
              console.log('ğŸ¯ .splat:', window.sparkRadius);
            }

          } else {
            const url = URL.createObjectURL(file);
            const fileType = {spz:SplatFileType.SPZ, ply:SplatFileType.PLY, ksplat:SplatFileType.KSPLAT}[ext];
            splat = new SplatMesh({ url, fileType });
            splat.quaternion.set(1, 0, 0, 0);
            splat.rotateZ(Math.PI);
            scene.add(splat);

                         await splat.initialized;
             window.splat = splat;
             window.sparkSplat = splat; // Spark
             
             if (splat.packedSplats) {
              const p = splat.packedSplats;
              console.log("packedSplats keys â†’", Object.keys(p));
              
              const scaleKey = Object.keys(p).find(k => /scale/i.test(k));
              const rotKey = Object.keys(p).find(k => /rot/i.test(k));
              const box = splat.getBoundingBox(false);
              console.log('BBox center:', box.getCenter(new THREE.Vector3()));
              console.log('BBox size  :', box.getSize(new THREE.Vector3()));
    
              if (scaleKey && rotKey && p[scaleKey] && p[rotKey]) {
                console.log("scaleX (5):", Array.from(p[scaleKey].slice(0,5)));
                console.log("rotX   (5):", Array.from(p[rotKey].slice(0,5)));
              } else {
                console.log("âš ï¸  scale/rot ï¼Œ");
              }
            } else {
              console.log("âš ï¸ splat.packedSplats ");
            }

            setTimeout(()=>URL.revokeObjectURL(url), 5000);
          }
          
          // ğŸ¯ bbox
          if (!window.sparkBbox || window.sparkBbox[0] === -9999) {
            // bboxï¼ˆï¼‰
            window.sparkBbox = [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05];
            console.log('ğŸ¯ bbox:', window.sparkBbox);
          }
          if (!window.sparkFocalBounds) {
            // focal
            window.sparkFocalBounds = [1441, 999999999999999000];
            console.log('ğŸ¯ focal:', window.sparkFocalBounds);
          }
          if (!window.sparkRadius) {
            // 
            window.sparkRadius = 0.1;
            console.log('ğŸ¯ :', window.sparkRadius);
          }

          // ğŸ¯ ä¸ºdefaultåœºæ™¯è®¾ç½®worldåç§»ï¼Œä½¿å…¶ä¸ladybugåœºæ™¯è¡Œä¸ºä¸€è‡´
          if (!window.sparkWorldOffset || (window.sparkWorldOffset[0] === 0 && window.sparkWorldOffset[1] === 0 && window.sparkWorldOffset[2] === 0)) {
            // ä½¿ç”¨ladybugåœºæ™¯çš„targetPositionä½œä¸ºdefaultåœºæ™¯çš„worldåç§»
            const defaultWorldOffset = [0.,  0.,  -7.4713];
            sparkWorldOffset = [...defaultWorldOffset];
            window.sparkWorldOffset = [...defaultWorldOffset];
            console.log('ğŸ¯ defaultåœºæ™¯è®¾ç½®worldåç§»:', defaultWorldOffset);
          }

        }

        // 
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".splat,.spz,.ply,.ksplat";
        input.style.display = "none";
        input.onchange = e => loadFile(e.target.files[0]);
        document.body.appendChild(input);
        
        // 
        container.addEventListener("dblclick", ()=>input.click());
        
        // 
        container.addEventListener("dragover", e=>{ 
          e.preventDefault(); 
          container.style.outline = "4px dashed #0af";
        });
        container.addEventListener("dragleave", ()=>container.style.outline = "");
        container.addEventListener("drop", e => {
          e.preventDefault();
          container.style.outline = "";
          
          if (e.dataTransfer.files.length) {
            const files = Array.from(e.dataTransfer.files);
            let splatFile = null;
            
            files.forEach(file => {
              const ext = file.name.split(".").pop().toLowerCase();
              if (['splat', 'spz', 'ply', 'ksplat'].includes(ext)) {
                splatFile = file;
                console.log(`ğŸ¯ splat: ${file.name}`);
              }
            });
            
            if (splatFile) {
              loadFile(splatFile);
            } else {
              console.warn("âš ï¸ splat");
            }
          }
        });

        // 
        let frame=0, last=performance.now(), fps=0;
        const infoFov   = document.getElementById("spark-fov");
        const infoFocal = document.getElementById("spark-focal");
        const infoFps   = document.getElementById("spark-fps");
        const infoX     = document.getElementById("spark-posX");
        const infoY     = document.getElementById("spark-posY");
        const infoZ     = document.getElementById("spark-posZ");
        const infoRx    = document.getElementById("spark-rotX");
        const infoRy    = document.getElementById("spark-rotY");
        const infoRz    = document.getElementById("spark-rotZ");
        const infoSplatCount = document.getElementById("spark-splatCount");
        const infoRenderedCount = document.getElementById("spark-renderedCount");
        const infoSpeedFactor = document.getElementById("spark-speedFactor");
        const infoOrbitStatus = document.getElementById("spark-orbitStatus");
        const infoSplitStatus = document.getElementById("spark-splitStatus");

        function fovToFx(fov, h=480){ return (h/2)/Math.tan(THREE.MathUtils.degToRad(fov)/2); }
        function updateInfo(){
          frame++;
          const now=performance.now();
          if(now-last>=1000){ fps=Math.round(frame*1000/(now-last)); frame=0; last=now; }
          infoFov.textContent   = camera.fov.toFixed(1)+"Â°";
          infoFocal.textContent = fovToFx(camera.fov).toFixed(0)+"px";
          infoFps.textContent   = fps;
          infoX.textContent     = camera.position.x.toFixed(2);
          infoY.textContent     = camera.position.y.toFixed(2);
          infoZ.textContent     = camera.position.z.toFixed(2);
          infoRx.textContent    = (camera.rotation.x*180/Math.PI).toFixed(1)+"Â°";
          infoRy.textContent    = (camera.rotation.y*180/Math.PI).toFixed(1)+"Â°";
          infoRz.textContent    = (camera.rotation.z*180/Math.PI).toFixed(1)+"Â°";
          
          // splat
          if (window.splatFirst && window.splatSecond) {
            const firstCount = window.splatFirst.packedSplats ? window.splatFirst.packedSplats.numSplats : 0;
            const secondCount = window.splatSecond.packedSplats ? window.splatSecond.packedSplats.numSplats : 0;
            const totalCount = firstCount + secondCount;
            const currentFocal = fovToFx(camera.fov);
            const useSecondSplat = currentFocal > (window.sparkSplitThreshold || 3000);
            const renderedCount = useSecondSplat ? secondCount : firstCount;
            
            infoSplatCount.textContent = totalCount;
            infoRenderedCount.textContent = renderedCount;
          } else if (splat && splat.packedSplats) {
            infoSplatCount.textContent = splat.packedSplats.numSplats || 0;
            infoRenderedCount.textContent = splat.packedSplats.numSplats || "?";
          } else {
            infoSplatCount.textContent = "0";
            infoRenderedCount.textContent = "?";
          }
          
          const speedFactor = getSpeedFactor();
          infoSpeedFactor.textContent = speedFactor.toFixed(2);
          
          infoOrbitStatus.textContent = orbitMode ? "ON" : "OFF";
          
          // 
          if (window.splatFirst && window.splatSecond) {
            const currentFocal = fovToFx(camera.fov);
            const useSecondSplat = currentFocal > (window.sparkSplitThreshold || 3000);
            infoSplitStatus.textContent = useSecondSplat ? "SECOND" : "FIRST";
          } else {
            infoSplitStatus.textContent = "OFF";
          }
        }

                 //  -  
         document.addEventListener("sparkKeyDown", e=>{
           const keyCode = e.detail.code;
           
           if(keyCode==="KeyV"){
             const currentFocal = fovToFx(camera.fov);
             const maxFocal = window.sparkFocalBounds ? window.sparkFocalBounds[1] : 30000000;
             const newFocal = Math.min(currentFocal * 1.05, maxFocal);
             const newFov = 2 * Math.atan((480/2) / newFocal) * 180 / Math.PI;
             camera.fov = newFov;
             camera.updateProjectionMatrix();
           }
           if(keyCode==="KeyB"){
             const currentFocal = fovToFx(camera.fov);
             const minFocal = window.sparkFocalBounds ? window.sparkFocalBounds[0] : 1441;
             const newFocal = Math.max(currentFocal / 1.05, minFocal);
             const newFov = 2 * Math.atan((480/2) / newFocal) * 180 / Math.PI;
             camera.fov = newFov;
             camera.updateProjectionMatrix();
           }
         });

        // 
        renderer.setAnimationLoop(()=>{
          controls.update(camera);
          updateInfo();
          
          // ğŸ¯ focal lengthsplat
          const currentFocal = fovToFx(camera.fov);
          const useSecondSplat = currentFocal > (window.sparkSplitThreshold || 3000);
          
          if (window.splatFirst && window.splatSecond) {
            window.splatFirst.visible = true; //!useSecondSplat; // focal â‰¤ threshold targetSplats
            window.splatSecond.visible = true; //useSecondSplat;  // focal > threshold 
          }
          
          renderer.render(scene,camera);
        });

          // 
          function resizeRenderer() {
            const rect = container.getBoundingClientRect();
            const width = rect.width || 600;
            const height = rect.height || 350;
           
           // canvas
           canvas.width = width;
           canvas.height = height;
           
           camera.aspect = width / height;
           camera.updateProjectionMatrix();
           renderer.setSize(width, height);
         }

        //  
        const resizeObserver = new ResizeObserver(resizeRenderer);
        resizeObserver.observe(container);
      }

              // 
        document.addEventListener('DOMContentLoaded', function() {
          // DOM
          setTimeout(initSparkRenderer, 100);
        });
        
                 // ğŸ¯ 
         // ğŸ¯ å¤ä½ScaleæŒ‰é’®åˆ°Scale 0çš„å‡½æ•°
         function resetScaleButtons() {
           document.querySelectorAll('.scale-button').forEach(btn => btn.classList.remove('active'));
           const scale0Button = document.querySelector('.scale-button[data-scale="0"]');
           if (scale0Button) {
             scale0Button.classList.add('active');
           }
           console.log('ğŸ¯ ScaleæŒ‰é’®å·²å¤ä½åˆ°Scale 0');
         }

         function initButtonHandlers() {
           const buttons = document.querySelectorAll('.button:not(.scale-button), .button-img');
           let currentActiveButton = null;

           buttons.forEach(button => {
             button.addEventListener('click', function(e) {
               // ï¼Œ
               e.stopPropagation();
               e.preventDefault();
               
               // ğŸ¯ å¦‚æœæ­£åœ¨ä¸‹è½½ï¼Œå…ˆå–æ¶ˆä¸‹è½½
               if (isDownloading && currentDownloadXHR) {
                 console.log('ğŸ¯ æ£€æµ‹åˆ°æ­£åœ¨ä¸‹è½½ï¼Œå…ˆå–æ¶ˆå½“å‰ä¸‹è½½');
                 currentDownloadXHR.abort();
                 currentDownloadXHR = null;
                 isDownloading = false;
                 
                 // éšè—è¿›åº¦æ¡
                 const progressContainer = document.getElementById('download-progress-container');
                 if (progressContainer) {
                   progressContainer.style.display = 'none';
                 }
               }
               
               if (currentActiveButton !== this) {
                // ğŸ¯ å¦‚æœå½“å‰æœ‰åŠ è½½çš„åœºæ™¯ï¼Œå…ˆæ¸…é™¤
                if (currentActiveButton && (window.sparkSplat || window.splatFirst || window.splatSecond)) {
                  console.log('ğŸ¯ æ£€æµ‹åˆ°å·²åŠ è½½åœºæ™¯ï¼Œå…ˆæ¸…é™¤å½“å‰åœºæ™¯');
                  handleSparkClear();
                  
                  // ç­‰å¾…æ¸…é™¤å®Œæˆåå†åŠ è½½æ–°åœºæ™¯
                  setTimeout(() => {
                    // Remove active class from all buttons
                    buttons.forEach(btn => btn.classList.remove('active'));

                    // Add active class to the clicked button
                    this.classList.add('active');

                    currentActiveButton = this;

                    // ğŸ¯ å¤ä½ScaleæŒ‰é’®åˆ°Scale 0
                    resetScaleButtons();

                    // Call the function to handle the active button change
                    if (this.dataset.url) {
                      handleSparkButtonChange(this.dataset.url);
                    } else {
                      handleSparkClear();
                    }
                  }, 100);
                } else {
                  // æ²¡æœ‰åŠ è½½åœºæ™¯ï¼Œç›´æ¥å¤„ç†
                  // Remove active class from all buttons
                  buttons.forEach(btn => btn.classList.remove('active'));

                  // Add active class to the clicked button
                  this.classList.add('active');

                  currentActiveButton = this;

                  // ğŸ¯ å¤ä½ScaleæŒ‰é’®åˆ°Scale 0
                  resetScaleButtons();

                  // Call the function to handle the active button change
                   if (this.dataset.url) {
                     handleSparkButtonChange(this.dataset.url);
                   } else {
                     handleSparkClear();
                   }
                }
               } else {
                 // ğŸ¯ ç‚¹å‡»åŒä¸€ä¸ªæŒ‰é’®ï¼Œå¦‚æœæ­£åœ¨ä¸‹è½½åˆ™é‡æ–°ä¸‹è½½
                 if (this.dataset.url) {
                   console.log('ğŸ¯ ç‚¹å‡»åŒä¸€ä¸ªæŒ‰é’®ï¼Œé‡æ–°å¼€å§‹ä¸‹è½½');
                   // å·²ç»åœ¨ä¸Šé¢å–æ¶ˆäº†ä¸‹è½½ï¼Œè¿™é‡Œå»¶è¿Ÿä¸€ä¸‹å†é‡æ–°å¼€å§‹ï¼Œç¡®ä¿çŠ¶æ€å®Œå…¨é‡ç½®
                   setTimeout(() => {
                     handleSparkButtonChange(this.dataset.url);
                   }, 50);
                 }
               }
               
               // ğŸ¯ body
               setTimeout(() => {
                 document.body.focus();
               }, 50);
             });
           });
         }

         // ğŸ¯ 
         function smoothTransitionToCamera(targetSettings, duration = 2000) {
           if (!window.sparkCamera) {
             console.warn('ğŸ¯ ');
             return;
           }

           // fovToFx
           function fovToFx(fov, h = 480) { 
             return (h/2)/Math.tan(THREE.MathUtils.degToRad(fov)/2); 
           }

           // ï¼ˆï¼‰
           window.sparkCameraTransitioning = true;

           const startTime = Date.now();
           const startPosition = {
             x: window.sparkCamera.position.x,
             y: window.sparkCamera.position.y,
             z: window.sparkCamera.position.z
           };
           const startFocal = fovToFx(window.sparkCamera.fov);
           const startYaw = window.sparkLocalYaw || 0;
           const startPitch = window.sparkLocalPitch || 0;

           const targetPosition = targetSettings.position;
           const targetFocal = targetSettings.focal;
           // yawpitch
           const targetYaw = targetSettings.yaw;
           const targetPitch = targetSettings.pitch;
           // 
           if (targetSettings.orbitRadius !== undefined) {
             window.sparkOrbitRadius = targetSettings.orbitRadius;
             console.log('ğŸ¯ :', window.sparkOrbitRadius);
           }
          // 
          if (targetSettings.radius !== undefined) {
            window.sparkRadius = targetSettings.radius;
            console.log('ğŸ¯ :', window.sparkRadius);
          }
          // ğŸ¯ æ›´æ–°bboxï¼ˆåŒ…å«yaw/pitché™åˆ¶ï¼‰
          if (targetSettings.bbox !== undefined) {
            window.sparkBbox = targetSettings.bbox;
            console.log('ğŸ¯ æ›´æ–°bbox (åŒ…å«yaw/pitché™åˆ¶):', window.sparkBbox);
          }

          const radiusCenterTarget = targetSettings.radiusCenter || targetSettings.position || ZERO_VECTOR;

           function animate() {
             const currentTime = Date.now();
             const elapsed = currentTime - startTime;
             const progress = Math.min(elapsed / duration, 1);
             
             // easeInOutQuad
             const easeProgress = progress < 0.5 
               ? 2 * progress * progress 
               : 1 - Math.pow(-2 * progress + 2, 2) / 2;

             // 
             window.sparkCamera.position.x = startPosition.x + (targetPosition[0] - startPosition.x) * easeProgress;
             window.sparkCamera.position.y = startPosition.y + (targetPosition[1] - startPosition.y) * easeProgress;
             window.sparkCamera.position.z = startPosition.z + (targetPosition[2] - startPosition.z) * easeProgress;

             // focal length
             const currentFocal = startFocal + (targetFocal - startFocal) * easeProgress;
             const newFov = 2 * Math.atan((480/2) / currentFocal) * 180 / Math.PI;
             window.sparkCamera.fov = newFov;
             window.sparkCamera.updateProjectionMatrix();

             // yawpitch0
             const currentYaw = startYaw + (targetYaw - startYaw) * easeProgress;
             const currentPitch = startPitch + (targetPitch - startPitch) * easeProgress;
             
             // 
             window.updateLocalRotation(currentYaw, currentPitch);
            
             if (progress < 1) {
               requestAnimationFrame(animate);
             } else {
               // ï¼Œ0
              //  window.updateLocalRotation(0, 0);
               
               window.sparkCameraTransitioning = false;
               sparkRadiusCenter = [radiusCenterTarget[0] ?? 0, radiusCenterTarget[1] ?? 0, radiusCenterTarget[2] ?? 0];
               window.sparkRadiusCenter = [...sparkRadiusCenter];
               console.log(`ğŸ¯ : [${targetPosition}], Focal: ${targetFocal}, Yaw: 0, Pitch: 0`);
             }
           }

           animate();
         }

         // ğŸ¯ Scale
         function getScaleSettings(scale) {
           // URL
           const activeButton = document.querySelector('.button-img.active, .button.active');
           let sceneType = 'default';
           
           if (activeButton && activeButton.dataset.url) {
             const url = activeButton.dataset.url;
             if (url.includes('ladybug')) sceneType = 'ladybug';
             else if (url.includes('beetle')) sceneType = 'beetle';
             else if (url.includes('bird')) sceneType = 'bird';
             else if (url.includes('fish')) sceneType = 'fish';
             else if (url.includes('lego')) sceneType = 'lego';
             else if (url.includes('butterfly')) sceneType = 'butterfly';
             else if (url.includes('conch')) sceneType = 'conch';
             else if (url.includes('lizard')) sceneType = 'lizard';
           }
           
             // Scale pitch: 0.0036574133674608616 yaw: 0.005105210012827155 bird
             // Scale pitch: 0.0014973227702496717 yaw: -0.00197982707479749 conch
             const scaleSettings = {
            default:{
                '0': { position: [0.0, 0.0, 0.0], focal: 1441, yaw: 0, pitch: 0, orbitRadius: 0.15, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05] },
                '1': { position: [0.0, 0.0, 0.0], focal: 6329, yaw:0, pitch:  0, orbitRadius: 0.5, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] },
                '2': { position: [0.0, 0.0, 0.0], focal: 221752, yaw: 0, pitch:  0, orbitRadius: 0.8, radius: 0.01, bbox: [-9999, 9999, -9999, 9999, -0.001, 0.001, -0.001, 0.001] }
              },
              ladybug: {
                '0': { position: [0.0, 0.0, 0.0], focal: 1441, yaw: 0, pitch: 0, orbitRadius: 0.3, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05] },
                '1': { position: [0.0, 0.0, 0.0], focal: 4041, yaw: 0, pitch: 0, orbitRadius: 0.2, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] },
                '2': { position: [0.0, 0.0, 0.0], focal: 43841, yaw: 0.0008027873451791703, pitch: -0.0006713122419652838, orbitRadius: 1.0, radius: 0.1, bbox: [-0.02, 0.02, -9999, 9999, -0.001, 0.001, -0.001, 0.001] }
              },
              bird:{
                '0': { position: [0.0, 0.0, 0.0], focal: 1441, yaw: 0, pitch: 0, orbitRadius: 0.3, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05] },
                '1': { position: [0.0, 0.0, 0.0], focal: 14980, yaw: 0.005105210012827155, pitch:  0.0036574133674608616, orbitRadius: 0.3, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] },
                '2': { position: [0.0, 0.0, 0.0], focal: 91141, yaw: 0.005105210012827155, pitch:  0.0036574133674608616, orbitRadius: 0.8, radius: 0.1, bbox: [-0.02, 0.02, -9999, 9999, 0.0036574133674608616 -0.001, 0.0036574133674608616 +0.001, 0.005105210012827155 -0.001, 0.005105210012827155 +0.001] }
              },
              conch: {
                '0': { position: [0.0, 0.0, 0.0], focal: 1441, yaw: 0, pitch: 0, orbitRadius: 0.05, radius: 0.05, bbox: [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05] },
                '1': { position: [0.0, 0.0, 0.0], focal: 11743,yaw: -0.00197982707479749, pitch: 0.0014973227702496717, orbitRadius: 0.5, radius: 0.1, bbox: [-0.015, 0.015, -9999, 9999, -0.01, 0.01, -0.01, 0.01] },
                '2': { position: [0.0, 0.0, 0.0], focal: 43288, yaw: -0.00197982707479749, pitch: 0.0014973227702496717 , orbitRadius: 0.8, radius: 0.03, bbox: [-0.01, 0.01, -9999, 9999,  0.0014973227702496717 - 0.001,  0.0014973227702496717 + 0.001,-0.00197982707479749 -0.001 , -0.00197982707479749 +0.001]}
              },
              fish: {
                '0': { position: [0.0, 0.0, 0.0], focal: 1441, yaw: 0, pitch: 0, orbitRadius: 1., radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05] },
                '1': { position: [0.0, 0.0, 0.0], focal: 5124, yaw:0, pitch:  0, orbitRadius: 0.6, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] },
                '2': { position: [0.0, 0.0, 0.0], focal: 95712, yaw: 0, pitch:  0, orbitRadius: 1.3, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] }
              },
              butterfly: {
                '0': { position: [0.0, 0.0, 0.0], focal: 1441, yaw: 0, pitch: 0, orbitRadius: 0.5, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05] },
                '1': { position: [0.0, 0.0, 0.0], focal: 27352, yaw:0, pitch:  0, orbitRadius: 0.6, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] },
                '2': { position: [0.0, 0.0, 0.0], focal: 681120, yaw: 0, pitch:  0, orbitRadius: 1.3, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] }
              },
              lego: {
                '0': { position: [0.0, 0.0, 0.0], focal: 1441, yaw: 0, pitch: 0, orbitRadius: 0.15, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05] },
                '1': { position: [0.0, 0.0, 0.0], focal: 6329, yaw:0, pitch:  0, orbitRadius: 0.5, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] },
                '2': { position: [0.0, 0.0, 0.0], focal: 221752, yaw: 0, pitch:  0, orbitRadius: 0.8, radius: 0.01, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] }
              },
              lizard:{
                '0': { position: [0.0, 0.0, 0.0], focal: 1441, yaw: 0, pitch: 0, orbitRadius: 0.15, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05] },
                '1': { position: [0.0, 0.0, 0.0], focal: 27352, yaw:0, pitch:  0, orbitRadius: 0.5, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] },
                '2': { position: [0.0, 0.0, 0.0], focal: 83576, yaw: 0, pitch:  0, orbitRadius: 0.5, radius: 0.1, bbox: [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01] }
              },
 
             };
           
          const settings = scaleSettings[sceneType] && scaleSettings[sceneType][scale] 
            ? scaleSettings[sceneType][scale] 
            : scaleSettings.default[scale];

          const offset = sparkWorldOffset || ZERO_VECTOR;
          const adjustedPosition = subtractVectors(settings.position || ZERO_VECTOR, offset);
          const adjustedBbox = settings.bbox ? translateBbox(settings.bbox, offset) : settings.bbox;

          const radiusCenter = settings.radiusCenter
            ? subtractVectors(settings.radiusCenter, offset)
            : adjustedPosition;

          const adjustedSettings = {
            ...settings,
            position: adjustedPosition,
            bbox: adjustedBbox ? [...adjustedBbox] : adjustedBbox,
            radiusCenter
          };
            
          console.log(`ğŸ¯ : ${sceneType}, Scale: ${scale}`, adjustedSettings);
          console.log(`ğŸ¯ : ${adjustedSettings.orbitRadius}, : ${adjustedSettings.radius}, : [${adjustedSettings.position}], Focal: ${adjustedSettings.focal}, Yaw: ${adjustedSettings.yaw}, Pitch: ${adjustedSettings.pitch}`);
          return adjustedSettings;
        }

         // ğŸ¯ Scale
         function initScaleButtons() {
           const scaleButtons = document.querySelectorAll('.scale-button');
           
           scaleButtons.forEach(button => {
             button.addEventListener('click', function(e) {
               e.stopPropagation();
               e.preventDefault();
               
               if (!window.sparkCamera) {
                 console.warn('ğŸ¯ ');
                 return;
               }
               
               const scale = this.dataset.scale;
               
               // scaleactive
               scaleButtons.forEach(btn => btn.classList.remove('active'));
               // active
               this.classList.add('active');
               
               // Scale
               let targetSettings = getScaleSettings(scale);
               console.log(`ğŸ¯  Scale ${scale}`);
               
               // ï¼ˆrotationï¼‰
               smoothTransitionToCamera(targetSettings);
               
               // body
               setTimeout(() => {
                 document.body.focus();
               }, 50);
             });
           });
         }

                 // ğŸ¯ å…¨å±€å˜é‡ç”¨äºè·Ÿè¸ªä¸‹è½½çŠ¶æ€
         let currentDownloadXHR = null;
         let isDownloading = false;

         // ğŸ¯ Spark
         async function handleSparkButtonChange(activeButtonUrl) {
           console.log(`ğŸ¯ Spark: ${activeButtonUrl}`);
           
           // splat
           if (window.sparkSplat) {
             window.sparkScene.remove(window.sparkSplat);
             window.sparkSplat.dispose?.();
             window.sparkSplat = null;
           }
           
           // splat
           if (window.splatFirst) {
             window.sparkScene.remove(window.splatFirst);
             window.splatFirst.dispose?.();
             window.splatFirst = null;
           }
           if (window.splatSecond) {
             window.sparkScene.remove(window.splatSecond);
             window.splatSecond.dispose?.();
             window.splatSecond = null;
           }

           // ğŸ¯ splat
           let initialPosition = [0, 0, 0];
           let initialFocal = 1441;
           let initialYaw = 0;
           let initialPitch = 0;
           let initialRotation = [0, 0, 0]; // [X, Y, Z] 
           let bbox = [-9999, 9999, -9999, 9999, -0.01, 0.01, -0.01, 0.01]; // : [minx, maxx, minz, maxz, minpitch, maxpitch, minyaw, maxyaw]
           let focalBounds = [1441, 999999999999999000]; // Focal: [minFocal, maxFocal]
           let targetPosition = [0, 0, -1.2]; // 
           let splitThreshold = 3000; // 
           let targetSplats = 5950100; // 
           let radius = 9999; // 
           let orbitRadius = 0.1; // ğŸ¯ è½¨é“åŠå¾„
           
            if (activeButtonUrl.includes('ladybug')) {
              initialPosition = [0.0, 0.0, 0.0];
              initialFocal = 1441;
              bbox = [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05];
              //focalBounds = [800, 2500];
              targetPosition = [-5.1574e-3, -4.0808e-3, -6.8847]; // 
              splitThreshold = 2900;
              targetSplats = 59500001;
              radius = 0.15; // 
            }
           else if (activeButtonUrl.includes('bird')) {
              initialPosition = [0, 0, 0];
              initialFocal = 1441;
              // focalBounds = [800, 1500];
              bbox = [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05];
              targetPosition = [-0.0306, 0.0250, -6.3509]; // 
              splitThreshold = 2500;
              targetSplats = 800000000;
              radius = 0.12; // 
            }
            else if (activeButtonUrl.includes('conch')) {
               initialPosition = [0.014332685967334207, 0, -0.04401724574130725];
               initialFocal = 1441;
               
               // focalBounds = [800, 1500];
               bbox = [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05];
               targetPosition = [0.0188, 0.0105, -9.3264]; // 
               splitThreshold = 2800;
               targetSplats = 70000;
               radius = 0.1; // 
               orbitRadius = 0.05; // ğŸ¯ conchåœºæ™¯çš„è½¨é“åŠå¾„
             }
           else if (activeButtonUrl.includes('fish')) {
             initialPosition = [0, 0, 0];
             initialFocal = 1441;
             // focalBounds = [800, 1500];
             targetPosition = [0,0,-10.6012]; // 
             splitThreshold = 3000;
             targetSplats = 100000;
             radius = 0.2; // 
           }
           else if (activeButtonUrl.includes('lizard')) {
             initialPosition = [0.0220,  0.0285,  -7.4713] ;
             initialFocal = 1700;
             bbox = [-0.2, 0.3, -3.2, 0.2, -0.2, 0.16, -0.12, 0.3];
             // focalBounds = [1200, 2200];
             targetPosition =[0.,  0.,  -7.4713] //[0.0220,  0.0285,  -7.4713]; // 
             splitThreshold = 3200;
             targetSplats = 120000;
             radius = 0.25; // 
           }
           else if (activeButtonUrl.includes('butterfly')) {
             initialPosition = [0, 0, 0];
             initialFocal = 1441;
             bbox = [-9999, 9999, -9999, 9999, -0.03, 0.3, -9999, 9999];
             // focalBounds = [800, 1500];
            //  targetPosition = [-0.016, -0.017, -9.9911]; // 
            targetPosition = [-0., -0., -9.9911];
             splitThreshold = 2700;
             targetSplats = 90000;
             radius = 0.1; // 
           }
           else if (activeButtonUrl.includes('lego')) {
             initialPosition = [0, 0, 0];
             initialFocal = 900;
             bbox = [-9999, 9999, -9999, 9999, -0.1, 0.35, -9999, 9999];
             // focalBounds = [600, 1200];
             targetPosition = [-0.,  0.,  -9.9030]; // 
             splitThreshold = 2600;
             targetSplats = 110000;
             radius = 0.13; // wo
           }
          else {
              initialPosition = [0, 0, 0];
              initialFocal = 1024;
              // focalBounds = [800, 1500];
              targetPosition = [-0.0306, 0.0250, -6.3509]; // 
              splitThreshold = 2500;
              targetSplats = 800000000;
              radius = 9999; // 
            }

          const sceneWorldOffset = [...targetPosition];
          sparkWorldOffset = [...sceneWorldOffset];
          window.sparkWorldOffset = [...sceneWorldOffset];

          initialPosition = subtractVectors(initialPosition, sceneWorldOffset);
          bbox = translateBbox(bbox, sceneWorldOffset);

          const translatedTargetPosition = [...ZERO_VECTOR];
          targetPosition = translatedTargetPosition;

          try {
            // ğŸ¯ æ˜¾ç¤ºè¿›åº¦æ¡
            const progressContainer = document.getElementById('download-progress-container');
             const progressBar = document.getElementById('download-progress-bar');
             const progressPercentage = document.getElementById('download-percentage');
             const downloadStatus = document.getElementById('download-status');
             const downloadSize = document.getElementById('download-size');
             const downloadSpeed = document.getElementById('download-speed');
             const downloadEta = document.getElementById('download-eta');
             
             progressContainer.style.display = 'block';
             downloadStatus.textContent = 'Connecting...';
             progressBar.style.width = '0%';
             progressPercentage.textContent = '0%';
             downloadEta.textContent = '--:--';
             
             let startTime = Date.now();
             let lastLoaded = 0;
             let lastTime = startTime;
             
             // ä½¿ç”¨XMLHttpRequestç»•è¿‡CORSå¹¶æ˜¾ç¤ºè¿›åº¦
             const arrayBuffer = await new Promise((resolve, reject) => {
               const xhr = new XMLHttpRequest();
               currentDownloadXHR = xhr; // ä¿å­˜XHRå¼•ç”¨
               isDownloading = true; // è®¾ç½®ä¸‹è½½çŠ¶æ€
               xhr.open('GET', activeButtonUrl, true);
               xhr.responseType = 'arraybuffer';
               
               xhr.onprogress = function(e) {
                 if (e.lengthComputable) {
                   const percentage = Math.round((e.loaded / e.total) * 100);
                   const loadedMB = (e.loaded / 1024 / 1024).toFixed(1);
                   const totalMB = (e.total / 1024 / 1024).toFixed(1);
                   
                   // æ›´æ–°è¿›åº¦æ¡
                   progressBar.style.width = percentage + '%';
                   progressPercentage.textContent = percentage + '%';
                   downloadSize.textContent = `${loadedMB} MB / ${totalMB} MB`;
                   downloadStatus.textContent = 'Downloading...';
                   
                   // è®¡ç®—ä¸‹è½½é€Ÿåº¦
                   const currentTime = Date.now();
                   const timeDiff = (currentTime - lastTime) / 1000; // ç§’
                   const dataDiff = e.loaded - lastLoaded; // å­—èŠ‚
                   
                   if (timeDiff > 0.5) { // æ¯0.5ç§’æ›´æ–°ä¸€æ¬¡é€Ÿåº¦
                     const speedBps = dataDiff / timeDiff; // å­—èŠ‚/ç§’
                     const speedKBps = (speedBps / 1024).toFixed(1);
                     const speedMBps = (speedBps / 1024 / 1024).toFixed(1);
                     
                     // æ›´æ–°é€Ÿåº¦æ˜¾ç¤º
                     if (speedBps > 1024 * 1024) {
                       downloadSpeed.textContent = `${speedMBps} MB/s`;
                     } else {
                       downloadSpeed.textContent = `${speedKBps} KB/s`;
                     }
                     
                     // ğŸ¯ è®¡ç®—å‰©ä½™æ—¶é—´ ETA (ä½¿ç”¨å¹³å‡é€Ÿåº¦ï¼Œä¸æ˜¯ç¬æ—¶é€Ÿåº¦)
                     const remainingBytes = e.total - e.loaded;
                     const totalElapsedTime = (currentTime - startTime) / 1000; // æ€»ç”¨æ—¶(ç§’)
                     const averageSpeedBps = e.loaded / totalElapsedTime; // å¹³å‡é€Ÿåº¦(å­—èŠ‚/ç§’)
                     
                     if (averageSpeedBps > 0 && remainingBytes > 0 && totalElapsedTime > 1) {
                       const etaSeconds = remainingBytes / averageSpeedBps;
                       
                       if (etaSeconds < 60) {
                         downloadEta.textContent = `${Math.ceil(etaSeconds)}s`;
                       } else if (etaSeconds < 3600) {
                         const minutes = Math.floor(etaSeconds / 60);
                         const seconds = Math.ceil(etaSeconds % 60);
                         downloadEta.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                       } else {
                         const hours = Math.floor(etaSeconds / 3600);
                         const minutes = Math.floor((etaSeconds % 3600) / 60);
                         downloadEta.textContent = `${hours}:${minutes.toString().padStart(2, '0')}:00`;
                       }
                     } else {
                       downloadEta.textContent = '--:--';
                     }
                     
                     lastLoaded = e.loaded;
                     lastTime = currentTime;
                   }
                 }
               };
               
               xhr.onload = function() {
                 if (xhr.status === 200) {
                   downloadStatus.textContent = 'Download Complete!';
                   downloadEta.textContent = '0:00';
                   progressBar.style.background = '#4CAF50';
                   setTimeout(() => {
                     progressContainer.style.display = 'none';
                   }, 1000);
                   isDownloading = false; // é‡ç½®ä¸‹è½½çŠ¶æ€
                   currentDownloadXHR = null; // æ¸…é™¤XHRå¼•ç”¨
                   resolve(xhr.response);
                 } else {
                   downloadStatus.textContent = 'Download Failed';
                   downloadEta.textContent = '--:--';
                   progressBar.style.background = '#f44336';
                   isDownloading = false; // é‡ç½®ä¸‹è½½çŠ¶æ€
                   currentDownloadXHR = null; // æ¸…é™¤XHRå¼•ç”¨
                   reject(new Error(`HTTP ${xhr.status}: Unable to load ${activeButtonUrl}`));
                 }
               };
               
               xhr.onerror = () => {
                 downloadStatus.textContent = 'Network Error';
                 downloadEta.textContent = '--:--';
                 progressBar.style.background = '#f44336';
                 isDownloading = false; // é‡ç½®ä¸‹è½½çŠ¶æ€
                 currentDownloadXHR = null; // æ¸…é™¤XHRå¼•ç”¨
                 reject(new Error('Network error'));
               };
               
               xhr.onabort = () => {
                 downloadStatus.textContent = 'Download Cancelled';
                 downloadEta.textContent = '--:--';
                 progressBar.style.background = '#ff9800';
                 isDownloading = false; // é‡ç½®ä¸‹è½½çŠ¶æ€
                 currentDownloadXHR = null; // æ¸…é™¤XHRå¼•ç”¨
                 reject(new Error('Download cancelled'));
               };
               
               xhr.send();
             });
             const originalBytes = new Uint8Array(arrayBuffer);
             const totalBytes = originalBytes.length;
             
             // targetSplats
             // splat32 (position 12 + scale 12 + rotation 4 + color 4)
             const bytesPerSplat = 32;
             const targetBytes = targetSplats * bytesPerSplat;
             const halfBytes = Math.min(targetBytes, totalBytes);
             
             const firstHalfBytes = originalBytes.slice(0, halfBytes); // targetSplats
             const secondHalfBytes = originalBytes.slice(halfBytes); // 
             
             console.log(`ğŸ¯ : ${totalBytes} â†’ ${targetSplats}:${firstHalfBytes.length}, :${secondHalfBytes.length}`);
             console.log(`ğŸ¯ Debug - targetSplats: ${targetSplats}, targetBytes: ${targetBytes}, halfBytes: ${halfBytes}`);
             
             const currentFileType = SplatFileType.SPLAT;
             
             // splat
             if (window.splatFirst) { window.sparkScene.remove(window.splatFirst); window.splatFirst.dispose?.(); }
             if (window.splatSecond) { window.sparkScene.remove(window.splatSecond); window.splatSecond.dispose?.(); }
             
             // targetSplatssplat
             window.splatFirst = new SplatMesh({
               fileBytes: firstHalfBytes,
               fileType: currentFileType
             });
             window.splatFirst.quaternion.set(1, 0, 0, 0);
             window.splatFirst.rotateZ(Math.PI);
             window.sparkScene.add(window.splatFirst);
             
             // splat
             window.splatSecond = new SplatMesh({
               fileBytes: secondHalfBytes,
               fileType: currentFileType
             });
             window.splatSecond.quaternion.set(1, 0, 0, 0);
             window.splatSecond.rotateZ(Math.PI);
             window.sparkScene.add(window.splatSecond);
             
             // splat
             await Promise.all([window.splatFirst.initialized, window.splatSecond.initialized]);
             
             // 
             // window.splatFirst  window.splatSecond 
             window.sparkSplat = window.splatFirst; // 
             console.log('ğŸ¯ Splat:', window.sparkSplat);
             
             // ğŸ¯ 
             if (window.sparkCamera) {
               // 
               window.sparkCamera.position.set(initialPosition[0], initialPosition[1], initialPosition[2]);

               // Rotation XYZ
               window.sparkCamera.rotation.set(
                 initialRotation[0] * Math.PI / 180, // X
                 initialRotation[1] * Math.PI / 180, // Y
                 initialRotation[2] * Math.PI / 180  // Z
               );

               sparkRadiusCenter = [initialPosition[0], initialPosition[1], initialPosition[2]];
               window.sparkRadiusCenter = [...sparkRadiusCenter];
               
               // FOV (focal length)
               const fov = 2 * Math.atan((480/2) / initialFocal) * 180 / Math.PI;
               window.sparkCamera.fov = fov;
               window.sparkCamera.updateProjectionMatrix();
               
               console.log(`ğŸ¯ : [${initialPosition}], [${initialRotation}], FOV: ${fov.toFixed(1)}Â°, Focal: ${initialFocal}`);
             }
             
             // ğŸ¯ 
             yaw = initialYaw;
             pitch = initialPitch;
             window.sparkYaw = yaw;
             window.sparkPitch = pitch;
             
        // ğŸ¯ focal
            window.sparkBbox = bbox;
            window.sparkFocalBounds = focalBounds;
        window.sparkTargetPosition = translatedTargetPosition;
        window.sparkSplitThreshold = splitThreshold;
        window.sparkRadius = radius; // ğŸ¯
       window.sparkOrbitRadius = orbitRadius; // ğŸ¯ è®¾ç½®è½¨é“åŠå¾„ 
         
         
         console.log(`ğŸ¯ : [${bbox.join(', ')}]`);
         console.log(`ğŸ¯ focal: [${focalBounds.join(', ')}]`);
        console.log(`ğŸ¯ : [${translatedTargetPosition.join(', ')}], original offset: [${sceneWorldOffset.join(', ')}]`);
         console.log(`ğŸ¯ : ${splitThreshold}`);
         console.log(`ğŸ¯ : ${radius}`);
             
             
             // ğŸ¯ è‡ªåŠ¨è®¾ç½®ä¸ºScale 0
             setTimeout(() => {
               const scale0Button = document.querySelector('.scale-button[data-scale="0"]');
               if (scale0Button) {
                 // ç§»é™¤æ‰€æœ‰scaleæŒ‰é’®çš„activeçŠ¶æ€
                 document.querySelectorAll('.scale-button').forEach(btn => btn.classList.remove('active'));
                 // è®¾ç½®Scale 0ä¸ºactive
                 scale0Button.classList.add('active');
                 
                 // è·å–Scale 0çš„è®¾ç½®å¹¶åº”ç”¨
                 const scale0Settings = getScaleSettings('0');
                 smoothTransitionToCamera(scale0Settings);
                 
                 console.log('ğŸ¯ è‡ªåŠ¨è®¾ç½®ä¸ºScale 0');
               }
               
               document.body.focus();
               console.log('ğŸ¯ ');
             }, 100);
             
           } catch (error) {
             // åªæœ‰åœ¨ä¸æ˜¯å–æ¶ˆä¸‹è½½çš„æƒ…å†µä¸‹æ‰æ˜¾ç¤ºé”™è¯¯
             if (!error.message.includes('cancelled')) {
               console.error('âŒ Spark:', error);
             } else {
               console.log('ğŸ¯ ä¸‹è½½å·²å–æ¶ˆ');
             }
             // ğŸ¯ éšè—è¿›åº¦æ¡
             const progressContainer = document.getElementById('download-progress-container');
             if (progressContainer) {
               progressContainer.style.display = 'none';
             }
           }
         }

                 // ğŸ¯ Spark
         function handleSparkClear() {
           console.log('ğŸ¯ Spark');
           
           // ğŸ¯ å¦‚æœæ­£åœ¨ä¸‹è½½ï¼Œå…ˆå–æ¶ˆä¸‹è½½
           if (isDownloading && currentDownloadXHR) {
             console.log('ğŸ¯ å–æ¶ˆå½“å‰ä¸‹è½½');
             currentDownloadXHR.abort();
             currentDownloadXHR = null;
             isDownloading = false;
             
             // éšè—è¿›åº¦æ¡
             const progressContainer = document.getElementById('download-progress-container');
             if (progressContainer) {
               progressContainer.style.display = 'none';
             }
           }
           
           if (window.sparkSplat) {
             window.sparkScene.remove(window.sparkSplat);
             window.sparkSplat.dispose?.();
             window.sparkSplat = null;
           }
           
           // splat
           if (window.splatFirst) {
             window.sparkScene.remove(window.splatFirst);
             window.splatFirst.dispose?.();
             window.splatFirst = null;
           }
           if (window.splatSecond) {
             window.sparkScene.remove(window.splatSecond);
             window.splatSecond.dispose?.();
             window.splatSecond = null;
           }
           
           // ğŸ¯ 
           if (window.sparkCamera) {
             window.sparkCamera.position.set(0, 0, 0);
             window.sparkCamera.rotation.set(0, 0, 0);
             window.sparkCamera.fov = 2 * Math.atan((480/2) / 1024) * 180 / Math.PI;
             window.sparkCamera.updateProjectionMatrix();
           }

           // ğŸ¯ 
           yaw = 0;
           pitch = 0;
           orbitMode = false;
           activeKeys = [];

           // 
           window.sparkYaw = yaw;
           window.sparkPitch = pitch;
           window.sparkOrbitMode = orbitMode;
          sparkWorldOffset = [...ZERO_VECTOR];
          window.sparkWorldOffset = [...ZERO_VECTOR];
          window.sparkTargetPosition = [...ZERO_VECTOR];
          sparkRadiusCenter = [...ZERO_VECTOR];
          window.sparkRadiusCenter = [...ZERO_VECTOR];

           // ğŸ¯ focal
           window.sparkBbox = [-9999, 9999, -9999, 9999, -0.05, 0.05, -0.05, 0.05];
          //  window.sparkFocalBounds = [100, 3000];
          //  window.sparkRadius = 9999; // 
           
           console.log('ğŸ¯ : [0,0,0], FOV: 26.3Â°, Yaw: 0, Pitch: 0, focal');
           
           // ğŸ¯ è‡ªåŠ¨è®¾ç½®ä¸ºScale 0
           const scale0Button = document.querySelector('.scale-button[data-scale="0"]');
           if (scale0Button) {
             // ç§»é™¤æ‰€æœ‰scaleæŒ‰é’®çš„activeçŠ¶æ€
             document.querySelectorAll('.scale-button').forEach(btn => btn.classList.remove('active'));
             // è®¾ç½®Scale 0ä¸ºactive
             scale0Button.classList.add('active');
             
             // è·å–Scale 0çš„è®¾ç½®å¹¶åº”ç”¨
             const scale0Settings = getScaleSettings('0');
             smoothTransitionToCamera(scale0Settings);
             
             console.log('ğŸ¯ æ¸…é™¤åœºæ™¯åè‡ªåŠ¨è®¾ç½®ä¸ºScale 0');
           }
           
           console.log('ğŸ¯ ');
         }

                 // 
         document.addEventListener('DOMContentLoaded', function() {
           setTimeout(() => {
             initButtonHandlers();
             initScaleButtons();
           }, 500);
         });
         
         // 
         window.addEventListener('load', function() {
           setTimeout(() => {
             console.log('ğŸ¯ Window load ï¼ŒScale');
             initScaleButtons();
           }, 1000);
         });
         
         
         // ğŸ¯  ï¼Œ
         document.addEventListener('keydown', (e) => {
           // 
           const controlKeys = ['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyF', 'KeyV', 'KeyB', 
                               'KeyI', 'KeyJ', 'KeyK', 'KeyL'];
           
           if (controlKeys.includes(e.code)) {
             // ğŸ¯ æŒ‰é”®é«˜äº®æ•ˆæœ
             const keyBtn = document.querySelector(`.key-btn[data-key="${e.code}"]`);
             if (keyBtn) {
               keyBtn.style.background = 'rgba(0, 123, 255, 0.8)';
               keyBtn.style.borderColor = 'rgba(0, 123, 255, 1)';
               keyBtn.style.boxShadow = '0 0 10px rgba(0, 123, 255, 0.5)';
               keyBtn.style.transform = 'scale(0.95)';
             }
             
             // ï¼Œ
             if (!document.activeElement || 
                 (document.activeElement.tagName !== 'INPUT' && 
                  document.activeElement.tagName !== 'TEXTAREA' && 
                  document.activeElement.contentEditable !== 'true')) {
               
               // ï¼ŒSpark
               const customEvent = new CustomEvent('sparkKeyDown', { 
                 detail: { code: e.code, key: e.key } 
               });
               document.dispatchEvent(customEvent);
             }
           }
         });
         
         // ğŸ¯ æŒ‰é”®é‡Šæ”¾æ•ˆæœ
         document.addEventListener('keyup', (e) => {
           const controlKeys = ['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyF', 'KeyV', 'KeyB', 
                               'KeyI', 'KeyJ', 'KeyK', 'KeyL'];
           
           if (controlKeys.includes(e.code)) {
             // ğŸ¯ æ¢å¤æŒ‰é”®æ ·å¼
             const keyBtn = document.querySelector(`.key-btn[data-key="${e.code}"]`);
             if (keyBtn) {
               keyBtn.style.background = 'rgba(255,255,255,0.1)';
               keyBtn.style.borderColor = 'rgba(255,255,255,0.3)';
               keyBtn.style.boxShadow = 'none';
               keyBtn.style.transform = 'scale(1)';
             }
           }
         });
    </script>
    
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const videos = document.querySelectorAll('video[muted][loop]');

            const options = {
                root: null, // sets the framing element to the viewport
                threshold: 0.5 // at least 50% of the video must be visible
            };

            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.play();
                    } else {
                        entry.target.pause();
                        entry.target.currentTime = 0; // Reset the video to the beginning
                    }
                });
            }, options);

            videos.forEach(video => {
                observer.observe(video);
            });
        });

    </script>

</body>

</html>
